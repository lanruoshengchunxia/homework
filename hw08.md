# 1、阅读 PseudocodeStandard。（答案可以打印） 
1) 用伪代码描述将十进制转换成16进制的方法 
Input: OBTAIN    
IF OBTAIN  <0 THEN    
PRINT -    
COMPUTE OBTAIN as OBTAIN-2*OBTAIN    
ENDIF    
IF OBTAIN = 0 THEN   
PRINT 0   
ENDIF   
WHILE OBTAIN ≠ 0   
IF OBTAIN%16<10   
hexadecimal[I]=input%16+'0';   
Add 1 to I   
ELSE   
hexadecimal[I]=input%16+'0';   
Add 1 to I   
ENDIF   
input=input/16   
ENDWHILE   
FOR J←I downto 0    
PRINT hexadecimal[i]   
END FOR   


2) C语言实现（先用注释写好算法，然后翻译）

```c
#include<stdio.h>
int main(){
	int input,i=0;
	scanf("%d",&input);
	char hexadecimal[1000];
	if(input<0){
		printf("-");
		input=input-2*input;
	}
	if(input==0){
		printf("0");
	}
	while(input!=0){
		if(input%16<10){
			hexadecimal[i]=input%16+'0'; 
			i++;
		}
		else{
			hexadecimal[i]=input%16-10+'A';
			i++;
		}
		input/=16;
	}
	
	while(i--){
		printf("%c",hexadecimal[i]);
	}
}
```
3) 使用 -1,  0,  1,  15,   26，3265 最为输入测试你的程序
![](https://github.com/lanruoshengchunxia/swi-homework/raw/gh-pages/images/测试-1.png)<br>
![](https://github.com/lanruoshengchunxia/swi-homework/raw/gh-pages/images/测试0.png)<br>
![](https://github.com/lanruoshengchunxia/swi-homework/raw/gh-pages/images/测试1.png)<br>
![](https://github.com/lanruoshengchunxia/swi-homework/raw/gh-pages/images/测试15.png)<br>
![](https://github.com/lanruoshengchunxia/swi-homework/raw/gh-pages/images/测试26.png)<br>
![](https://github.com/lanruoshengchunxia/swi-homework/raw/gh-pages/images/测试3265.png)<br>


# 2、名词解释与对比 
1) Top-down design    
A top-down approach is essentially the breaking down of a system to gain insight into its compositional sub-systems in a reverse engineering fashion. In a top-down approach an overview of the system is formulated, specifying, but not detailing, any first-level subsystems. Each subsystem is then refined in yet greater detail, sometimes in many additional subsystem levels, until the entire specification is reduced to base elements.<br>
自顶向下的方法本质上是对系统进行分解，以以逆向工程的方式深入了解其组成子系统。在自顶向下的方法中，系统的概述被表达出来，指定但不详细描述任何一级子系统。然后对每个子系统进行更详细的细化，有时在许多额外的子系统级别，直到整个规范被简化为基本元素。<br>
2) Work breakdown structure (WBS)    
工作分解结构系将专案阶层分解成为阶段、交付标的、和工作包，它是一种为了达成目标〈例如：一个计划、专案、或契约〉所需要工作细分的树状结构。在一个专案或契约中，工作分解结构由其终端目标开始展开，并且就其大小、时间长短、责任划分〈亦即，系统、次系统、元件、任务、次任务、和工作包〉依次细分为可管理的组成，包括达成目标的所有必要步骤。 <BR>
3) 简述管理学WBS 与 信息学Top-down设计 的异同   
同：都是将大系统分解为多个小系统解决 <br>
异：Top-down是从上到下，WBS按照类型分<br>

# 3、仔细观察您洗衣机的运作过程，运用Top-down设计方法和Pseudocode 描述洗衣机控制程序。
假设洗衣机可执行的基本操作如下：<br> 
water_in_switch(open_close)  // open 打开上水开关，close关闭    
    water_out_switch(open_close)  // open 打开排水开关，close关闭    
        get_water_volume()  //返回洗衣机内部水的高度    
motor_run(direction) // 电机转动。left左转，right右转，stop停    
time_counter() // 返回当前时间计数，以秒为单位    
halt(returncode) //停机，success 成功 failure 失败
1) 请使用伪代码分解“正常洗衣”程序的大步骤。包括注水、浸泡等   
注水–浸泡–漂洗-排水–脱水 
2) 进一步用基本操作、控制语句（IF、FOR、WHILE等）、变量与表达式，写出每 个步骤的伪代码 <br>
注水:       
  SET now=timecounter();   
  WHILE getwatervolume()< volume   
    water_in_switch(open)   
    IF time_counter()=now+timeout   
      halt(failure)   
      BREAK   
    ENDIF   
  ENDWHILE   
  waterinswitch(close)    
浸泡：   
SET now=timecounter();   
WHILE timecounter()<=now+time   
ENDWHILE  
ENDIF   
漂洗：   
motor_run(oneside)   
WHILE  time_counter() = x   //x为单方向转动时间     
motor_run(anotherside)    
IF  time_counter()>y     //y为浸泡总时间   
motor_run(stop)   
ENDWHILE   
排水：   
SET now=time_counter();   
WHILE get_water_volume()>0    
water_out_switch(open)    
    IF time_counter()=now+timeout   
    halt(failure)   
    BREAK   
    ENDIF   
IF get_water_volume()=0   
water_out_switch(close)   
ENDIF    
END WHILE     
脱水：   
water_out_switch(open)   
motor_run(rightorleft)   
IF time_counter()>z   //z为脱水时间   
motor_run(stop)   
ENDIF   


3) 根据你的实践，请分析“正常洗衣”与“快速洗衣”在用户目标和程序上的异同。 你认为是否存在改进（创新）空间，简单说明你的改进意见？   
目标异：快速洗衣要求洗衣机在更短时间内洗完衣服   
目标同：洗干净衣服快速洗衣缩短浸泡和脱水总时间。    
程序异：快速洗衣应适当缩短漂洗和脱水时间，省去浸泡步骤
程序同：注水和排水程序不变  

4) 通过步骤3），提取一些共性功能模块（函数），简化“正常洗衣”程序，使程序 变得更利于人类理解和修改维护。例如： wait(time) //等待指定的时间； 注水(volume,timeout) //在指定时间内完成注水，否则停机； 排水(timeout)。等子程序 
  
FUNCTION wait(time)   
  WHILE timecounter()<=time   
  ENDWHILE   
ENDFUNCTION   

FUNCTION 注水(volume,timeout)
  SET now=timecounter();   
  WHILE getwatervolume()< volume   
    water_in_switch(open)   
    IF time_counter()=now+timeout           
      halt(failure)         
      BREAK          
    ENDIF       
  ENDWHILE          
  waterinswitch(close)           
ENDFUNCTION          

FUNCTION 排水(timeout)   
SET now=timecounter();   
WHILE get_water_volume()>0    
water_out_switch(open)    
    IF time_counter()=now+timeout   
    halt(failure)   
    BREAK   
    ENDIF   
IF get_water_volume()=0   
water_out_switch(close)   
ENDIF    
END WHILE 
ENDFUNCTION




